// Background learning scheduler — client-side scheduler for auto-learning
// Runs entirely outside React lifecycle via setInterval + Zustand getState()

import type { NotePage, NoteBlock } from '@/lib/notes/types';
import { readVersioned, writeVersioned, readString, writeString } from '@/lib/storage-versioning';

// ── Config type ──
export interface SchedulerConfig {
  enabled: boolean;
  intervalMinutes: number; // 30, 60, 120, 240
  depth: 'shallow' | 'moderate' | 'deep';
  maxIterations: number;
  enableDailyBrief: boolean;
  dailyBriefHour: number; // 0-23, e.g. 9 for 9 AM
}

// ── localStorage keys ──
const STORAGE_KEY_CONFIG = 'pfc-learning-scheduler';
const SCHEDULER_CONFIG_VERSION = 1;
const STORAGE_KEY_LAST_HASH = 'pfc-learning-last-hash';
const STORAGE_KEY_DAILY_BRIEF_LAST = 'pfc-daily-brief-last';

// ── Default config ──
const DEFAULT_CONFIG: SchedulerConfig = {
  enabled: false,
  intervalMinutes: 60,
  depth: 'moderate',
  maxIterations: 2,
  enableDailyBrief: false,
  dailyBriefHour: 9,
};

// ── Module state ──
let _schedulerTimer: ReturnType<typeof setInterval> | null = null;
let _lastNoteHash: string | null = null;

// ── Config persistence (versioned) ──
export function loadSchedulerConfig(): SchedulerConfig {
  const stored = readVersioned<SchedulerConfig>(STORAGE_KEY_CONFIG, SCHEDULER_CONFIG_VERSION);
  if (!stored) return DEFAULT_CONFIG;
  return { ...DEFAULT_CONFIG, ...stored };
}

export function saveSchedulerConfig(config: SchedulerConfig): void {
  writeVersioned(STORAGE_KEY_CONFIG, SCHEDULER_CONFIG_VERSION, config);
}

// ── Fast content hash to detect note changes ──
// Uses page count + block count + latest updatedAt timestamp
// This is O(n) but avoids deep content comparison
function computeNoteHash(pages: NotePage[], blocks: NoteBlock[]): string {
  const userPages = pages.filter((p) => p.properties?.autoGenerated !== 'true');
  const userPageIds = new Set(userPages.map((p) => p.id));
  const userBlocks = blocks.filter(
    (b) => b.properties?.autoGenerated !== 'true' && userPageIds.has(b.pageId),
  );

  let latestUpdate = 0;
  for (const p of userPages) {
    if (p.updatedAt > latestUpdate) latestUpdate = p.updatedAt;
  }
  for (const b of userBlocks) {
    if (b.updatedAt > latestUpdate) latestUpdate = b.updatedAt;
  }
  return `${userPages.length}:${userBlocks.length}:${latestUpdate}`;
}

function loadLastHash(): string | null {
  return readString(STORAGE_KEY_LAST_HASH);
}

function saveLastHash(hash: string): void {
  writeString(STORAGE_KEY_LAST_HASH, hash);
}

// ── Scheduler core ──

// The getState function returns the full store state (non-reactive)
type GetState = () => {
  learningSession: { status: string } | null;
  notePages: NotePage[];
  noteBlocks: NoteBlock[];
  startLearningSession: (depth: 'shallow' | 'moderate' | 'deep', maxIterations: number) => void;
  startDailyBriefSession: () => void;
};

function tick(getState: GetState, config: SchedulerConfig): void {
  const state = getState();

  // Don't start if a session is already running or paused
  const sessionStatus = state.learningSession?.status;
  if (sessionStatus === 'running' || sessionStatus === 'paused') return;

  // Don't run if there are no notes
  if (!state.notePages || state.notePages.length === 0) return;
  if (!state.notePages.some((p) => p.properties?.autoGenerated !== 'true')) return;

  // Check if notes have changed since last run
  const currentHash = computeNoteHash(state.notePages, state.noteBlocks ?? []);
  if (currentHash === _lastNoteHash) return; // No changes, skip

  // Notes changed — start a background learning session
  _lastNoteHash = currentHash;
  saveLastHash(currentHash);
  // Resolve iterations from depth if maxIterations is default (2)
  const depthIterations: Record<string, number> = { shallow: 1, moderate: 2, deep: 5 };
  const iterations = config.maxIterations === 2
    ? (depthIterations[config.depth] ?? config.maxIterations)
    : config.maxIterations;
  state.startLearningSession(config.depth, iterations);
}

function checkDailyBrief(getState: GetState, config: SchedulerConfig): void {
  if (!config.enableDailyBrief) return;

  const now = new Date();
  const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

  // Check if already generated today (persisted across page reloads)
  const lastGenerated = readString(STORAGE_KEY_DAILY_BRIEF_LAST);
  if (lastGenerated === today) return;

  // Check if it's past the configured hour
  if (now.getHours() < config.dailyBriefHour) return;

  // Don't run if a session is active
  const state = getState();
  const sessionStatus = state.learningSession?.status;
  if (sessionStatus === 'running' || sessionStatus === 'paused') return;

  // Don't run if there are no notes
  if (!state.notePages || state.notePages.length === 0) return;

  // Mark as generated for today
  writeString(STORAGE_KEY_DAILY_BRIEF_LAST, today);

  // Start daily brief
  state.startDailyBriefSession();
}

export function startScheduler(getState: GetState): void {
  stopScheduler();

  const config = loadSchedulerConfig();
  if (!config.enabled) return;

  // Load persisted hash to avoid immediate re-run on page reload
  _lastNoteHash = loadLastHash();

  // Set up the interval
  const intervalMs = config.intervalMinutes * 60 * 1000;
  _schedulerTimer = setInterval(() => {
    tick(getState, config);
    checkDailyBrief(getState, config);
  }, intervalMs);

  // Also check daily brief immediately (in case we missed the window)
  // Delay slightly to let the store hydrate
  setTimeout(() => {
    checkDailyBrief(getState, config);
  }, 5000);
}

export function stopScheduler(): void {
  if (_schedulerTimer) {
    clearInterval(_schedulerTimer);
    _schedulerTimer = null;
  }
}
