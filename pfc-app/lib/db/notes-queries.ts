import { db } from './index';
import {
  noteVault, notePage, noteBlock, noteBook,
  noteConcept, noteConceptCorrelation, notePageLink,
} from './schema';
import { eq, and } from 'drizzle-orm';
import type {
  NotePage, NoteBlock, NoteBook, Vault, Concept,
  ConceptCorrelation, PageLink,
} from '@/lib/notes/types';

// ═══════════════════════════════════════════════════════════════════
// Row ↔ Type converters
// JSON columns stored as TEXT in SQLite, parsed to TypeScript types
// ═══════════════════════════════════════════════════════════════════

function parseJSON<T>(raw: string | null, fallback: T): T {
  if (!raw) return fallback;
  try { return JSON.parse(raw) as T; } catch { return fallback; }
}

// ── Page ──

function rowToPage(r: typeof notePage.$inferSelect): NotePage {
  return {
    id: r.id,
    title: r.title,
    name: r.name,
    isJournal: !!r.isJournal,
    journalDate: r.journalDate ?? undefined,
    icon: r.icon ?? undefined,
    coverImage: r.coverImage ?? undefined,
    properties: parseJSON<Record<string, string>>(r.properties, {}),
    tags: parseJSON<string[]>(r.tags, []),
    favorite: !!r.favorite,
    pinned: !!r.pinned,
    createdAt: r.createdAt,
    updatedAt: r.updatedAt,
  };
}

function pageToRow(p: NotePage, vaultId: string) {
  return {
    id: p.id,
    vaultId,
    title: p.title,
    name: p.name,
    isJournal: p.isJournal,
    journalDate: p.journalDate ?? null,
    icon: p.icon ?? null,
    coverImage: p.coverImage ?? null,
    properties: JSON.stringify(p.properties),
    tags: JSON.stringify(p.tags),
    favorite: p.favorite,
    pinned: p.pinned,
    createdAt: p.createdAt,
    updatedAt: p.updatedAt,
  };
}

// ── Block ──

function rowToBlock(r: typeof noteBlock.$inferSelect): NoteBlock {
  return {
    id: r.id,
    pageId: r.pageId,
    type: r.type as NoteBlock['type'],
    content: r.content,
    parentId: r.parentId ?? null,
    order: r.blockOrder,
    collapsed: !!r.collapsed,
    indent: r.indent,
    properties: parseJSON<Record<string, string>>(r.properties, {}),
    refs: parseJSON<string[]>(r.refs, []),
    createdAt: r.createdAt,
    updatedAt: r.updatedAt,
  };
}

function blockToRow(b: NoteBlock) {
  return {
    id: b.id,
    pageId: b.pageId,
    type: b.type,
    content: b.content,
    parentId: b.parentId ?? null,
    blockOrder: b.order,
    collapsed: b.collapsed,
    indent: b.indent,
    properties: JSON.stringify(b.properties),
    refs: JSON.stringify(b.refs),
    createdAt: b.createdAt,
    updatedAt: b.updatedAt,
  };
}

// ── Book ──

function rowToBook(r: typeof noteBook.$inferSelect): NoteBook {
  return {
    id: r.id,
    title: r.title,
    description: r.description ?? undefined,
    icon: r.icon ?? undefined,
    coverColor: r.coverColor ?? undefined,
    pageIds: parseJSON<string[]>(r.pageIds, []),
    chapters: parseJSON<NoteBook['chapters']>(r.chapters, []),
    autoGenerated: !!r.autoGenerated,
    category: r.category ?? undefined,
    createdAt: r.createdAt,
    updatedAt: r.updatedAt,
  };
}

function bookToRow(b: NoteBook, vaultId: string) {
  return {
    id: b.id,
    vaultId,
    title: b.title,
    description: b.description ?? null,
    icon: b.icon ?? null,
    coverColor: b.coverColor ?? null,
    pageIds: JSON.stringify(b.pageIds),
    chapters: JSON.stringify(b.chapters),
    autoGenerated: b.autoGenerated,
    category: b.category ?? null,
    createdAt: b.createdAt,
    updatedAt: b.updatedAt,
  };
}

// ── Concept ──

function rowToConcept(r: typeof noteConcept.$inferSelect): Concept {
  return {
    id: r.id,
    name: r.name,
    sourcePageId: r.sourcePageId,
    sourceBlockId: r.sourceBlockId,
    type: r.type as Concept['type'],
    context: r.context,
    createdAt: r.createdAt,
  };
}

function conceptToRow(c: Concept, vaultId: string) {
  return {
    id: c.id,
    vaultId,
    name: c.name,
    sourcePageId: c.sourcePageId,
    sourceBlockId: c.sourceBlockId,
    type: c.type,
    context: c.context,
    createdAt: c.createdAt,
  };
}

// ── Correlation ──

function rowToCorrelation(r: typeof noteConceptCorrelation.$inferSelect): ConceptCorrelation {
  return {
    id: r.id,
    conceptAId: r.conceptAId,
    conceptBId: r.conceptBId,
    pageAId: r.pageAId,
    pageBId: r.pageBId,
    correlationType: r.correlationType as ConceptCorrelation['correlationType'],
    description: r.description,
    strength: r.strength,
    createdAt: r.createdAt,
  };
}

// ── Vault ──

function rowToVault(r: typeof noteVault.$inferSelect): Vault {
  return {
    id: r.id,
    name: r.name,
    description: r.description ?? undefined,
    icon: r.icon ?? undefined,
    pageCount: r.pageCount,
    createdAt: r.createdAt,
    updatedAt: r.updatedAt,
  };
}

// ═══════════════════════════════════════════════════════════════════
// Vault Queries
// ═══════════════════════════════════════════════════════════════════

export async function getVaults(): Promise<Vault[]> {
  const rows = await db.select().from(noteVault);
  return rows.map(rowToVault);
}

export async function getVaultById(id: string): Promise<Vault | null> {
  const row = await db.query.noteVault.findFirst({ where: eq(noteVault.id, id) });
  return row ? rowToVault(row) : null;
}

export async function upsertVault(v: Vault): Promise<void> {
  await db.insert(noteVault).values({
    id: v.id,
    name: v.name,
    description: v.description ?? null,
    icon: v.icon ?? null,
    pageCount: v.pageCount,
    createdAt: v.createdAt,
    updatedAt: v.updatedAt,
  }).onConflictDoUpdate({
    target: noteVault.id,
    set: {
      name: v.name,
      description: v.description ?? null,
      icon: v.icon ?? null,
      pageCount: v.pageCount,
      updatedAt: v.updatedAt,
    },
  }).run();
}

export async function deleteVault(id: string): Promise<void> {
  await db.delete(noteVault).where(eq(noteVault.id, id)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Page Queries
// ═══════════════════════════════════════════════════════════════════

export async function getPagesByVault(vaultId: string): Promise<NotePage[]> {
  const rows = await db.select().from(notePage).where(eq(notePage.vaultId, vaultId));
  return rows.map(rowToPage);
}

export async function upsertPage(p: NotePage, vaultId: string): Promise<void> {
  const row = pageToRow(p, vaultId);
  await db.insert(notePage).values(row).onConflictDoUpdate({
    target: notePage.id,
    set: {
      title: row.title,
      name: row.name,
      isJournal: row.isJournal,
      journalDate: row.journalDate,
      icon: row.icon,
      coverImage: row.coverImage,
      properties: row.properties,
      tags: row.tags,
      favorite: row.favorite,
      pinned: row.pinned,
      updatedAt: row.updatedAt,
    },
  }).run();
}

export async function deletePage(id: string): Promise<void> {
  await db.delete(notePage).where(eq(notePage.id, id)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Block Queries
// ═══════════════════════════════════════════════════════════════════

export async function getBlocksByVault(vaultId: string): Promise<NoteBlock[]> {
  // Join through note_page to get all blocks for a vault
  const rows = await db
    .select({ block: noteBlock })
    .from(noteBlock)
    .innerJoin(notePage, eq(noteBlock.pageId, notePage.id))
    .where(eq(notePage.vaultId, vaultId));
  return rows.map(r => rowToBlock(r.block));
}

export async function getBlocksByPage(pageId: string): Promise<NoteBlock[]> {
  const rows = await db.select().from(noteBlock).where(eq(noteBlock.pageId, pageId));
  return rows.map(rowToBlock);
}

export async function upsertBlock(b: NoteBlock): Promise<void> {
  const row = blockToRow(b);
  await db.insert(noteBlock).values(row).onConflictDoUpdate({
    target: noteBlock.id,
    set: {
      pageId: row.pageId,
      type: row.type,
      content: row.content,
      parentId: row.parentId,
      blockOrder: row.blockOrder,
      collapsed: row.collapsed,
      indent: row.indent,
      properties: row.properties,
      refs: row.refs,
      updatedAt: row.updatedAt,
    },
  }).run();
}

export async function deleteBlock(id: string): Promise<void> {
  await db.delete(noteBlock).where(eq(noteBlock.id, id)).run();
}

export async function deleteBlocksByPage(pageId: string): Promise<void> {
  await db.delete(noteBlock).where(eq(noteBlock.pageId, pageId)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Book Queries
// ═══════════════════════════════════════════════════════════════════

export async function getBooksByVault(vaultId: string): Promise<NoteBook[]> {
  const rows = await db.select().from(noteBook).where(eq(noteBook.vaultId, vaultId));
  return rows.map(rowToBook);
}

export async function upsertBook(b: NoteBook, vaultId: string): Promise<void> {
  const row = bookToRow(b, vaultId);
  await db.insert(noteBook).values(row).onConflictDoUpdate({
    target: noteBook.id,
    set: {
      title: row.title,
      description: row.description,
      icon: row.icon,
      coverColor: row.coverColor,
      pageIds: row.pageIds,
      chapters: row.chapters,
      autoGenerated: row.autoGenerated,
      category: row.category,
      updatedAt: row.updatedAt,
    },
  }).run();
}

export async function deleteBook(id: string): Promise<void> {
  await db.delete(noteBook).where(eq(noteBook.id, id)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Concept Queries
// ═══════════════════════════════════════════════════════════════════

export async function getConceptsByVault(vaultId: string): Promise<Concept[]> {
  const rows = await db.select().from(noteConcept).where(eq(noteConcept.vaultId, vaultId));
  return rows.map(rowToConcept);
}

export async function upsertConcept(c: Concept, vaultId: string): Promise<void> {
  const row = conceptToRow(c, vaultId);
  await db.insert(noteConcept).values(row).onConflictDoUpdate({
    target: noteConcept.id,
    set: { name: row.name, context: row.context },
  }).run();
}

export async function deleteConcept(id: string): Promise<void> {
  await db.delete(noteConcept).where(eq(noteConcept.id, id)).run();
}

export async function deleteConceptsByVault(vaultId: string): Promise<void> {
  await db.delete(noteConcept).where(eq(noteConcept.vaultId, vaultId)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Correlation Queries
// ═══════════════════════════════════════════════════════════════════

export async function getCorrelationsByVault(vaultId: string): Promise<ConceptCorrelation[]> {
  // Correlations reference concepts; join through concept to filter by vault
  const rows = await db
    .select({ corr: noteConceptCorrelation })
    .from(noteConceptCorrelation)
    .innerJoin(noteConcept, eq(noteConceptCorrelation.conceptAId, noteConcept.id))
    .where(eq(noteConcept.vaultId, vaultId));
  return rows.map(r => rowToCorrelation(r.corr));
}

export async function upsertCorrelation(c: ConceptCorrelation): Promise<void> {
  await db.insert(noteConceptCorrelation).values({
    id: c.id,
    conceptAId: c.conceptAId,
    conceptBId: c.conceptBId,
    pageAId: c.pageAId,
    pageBId: c.pageBId,
    correlationType: c.correlationType,
    description: c.description,
    strength: c.strength,
    createdAt: c.createdAt,
  }).onConflictDoUpdate({
    target: noteConceptCorrelation.id,
    set: {
      description: c.description,
      strength: c.strength,
    },
  }).run();
}

// ═══════════════════════════════════════════════════════════════════
// Page Link Queries
// ═══════════════════════════════════════════════════════════════════

export async function getPageLinksByVault(vaultId: string): Promise<PageLink[]> {
  const rows = await db
    .select({ link: notePageLink })
    .from(notePageLink)
    .innerJoin(notePage, eq(notePageLink.sourcePageId, notePage.id))
    .where(eq(notePage.vaultId, vaultId));
  return rows.map(r => ({
    sourcePageId: r.link.sourcePageId,
    targetPageId: r.link.targetPageId,
    sourceBlockId: r.link.sourceBlockId,
    context: r.link.context,
  }));
}

export async function replacePageLinks(vaultId: string, links: PageLink[]): Promise<void> {
  // Get all page IDs in this vault to scope deletion
  const vaultPages = await db.select({ id: notePage.id }).from(notePage).where(eq(notePage.vaultId, vaultId));
  const pageIdSet = new Set(vaultPages.map(p => p.id));

  // Delete existing links for this vault's pages
  for (const pid of pageIdSet) {
    await db.delete(notePageLink).where(eq(notePageLink.sourcePageId, pid)).run();
  }

  // Insert new links
  for (const link of links) {
    await db.insert(notePageLink).values({
      sourcePageId: link.sourcePageId,
      targetPageId: link.targetPageId,
      sourceBlockId: link.sourceBlockId,
      context: link.context,
    }).run();
  }
}

// ═══════════════════════════════════════════════════════════════════
// Bulk Sync — full vault write-through
// Used by the notes slice to persist entire vault state to SQLite
// ═══════════════════════════════════════════════════════════════════

export async function syncVaultToDb(
  vaultId: string,
  vault: Vault,
  pages: NotePage[],
  blocks: NoteBlock[],
  books: NoteBook[],
  concepts: Concept[],
  pageLinks: PageLink[],
): Promise<void> {
  // Upsert vault
  await upsertVault(vault);

  // Get existing IDs to compute deletes
  const existingPages = await db.select({ id: notePage.id }).from(notePage).where(eq(notePage.vaultId, vaultId));
  const existingPageIds = new Set(existingPages.map(p => p.id));
  const newPageIds = new Set(pages.map(p => p.id));

  // Delete removed pages (cascade deletes blocks)
  for (const ep of existingPageIds) {
    if (!newPageIds.has(ep)) {
      await db.delete(notePage).where(eq(notePage.id, ep)).run();
    }
  }

  // Upsert pages
  for (const p of pages) {
    await upsertPage(p, vaultId);
  }

  // For blocks: delete removed, upsert existing
  const existingBlocks = await db
    .select({ id: noteBlock.id })
    .from(noteBlock)
    .innerJoin(notePage, eq(noteBlock.pageId, notePage.id))
    .where(eq(notePage.vaultId, vaultId));
  const existingBlockIds = new Set(existingBlocks.map(b => b.id));
  const newBlockIds = new Set(blocks.map(b => b.id));

  for (const eb of existingBlockIds) {
    if (!newBlockIds.has(eb)) {
      await db.delete(noteBlock).where(eq(noteBlock.id, eb)).run();
    }
  }

  for (const b of blocks) {
    await upsertBlock(b);
  }

  // Books: delete removed, upsert existing
  const existingBooks = await db.select({ id: noteBook.id }).from(noteBook).where(eq(noteBook.vaultId, vaultId));
  const existingBookIds = new Set(existingBooks.map(b => b.id));
  const newBookIds = new Set(books.map(b => b.id));

  for (const eb of existingBookIds) {
    if (!newBookIds.has(eb)) {
      await db.delete(noteBook).where(eq(noteBook.id, eb)).run();
    }
  }

  for (const b of books) {
    await upsertBook(b, vaultId);
  }

  // Concepts: replace all for vault
  await deleteConceptsByVault(vaultId);
  for (const c of concepts) {
    await upsertConcept(c, vaultId);
  }

  // Page links: replace all for vault
  await replacePageLinks(vaultId, pageLinks);

  // Update vault page count
  await db.update(noteVault).set({
    pageCount: pages.length,
    updatedAt: Date.now(),
  }).where(eq(noteVault.id, vaultId)).run();
}

// ═══════════════════════════════════════════════════════════════════
// Load full vault from DB
// ═══════════════════════════════════════════════════════════════════

export async function loadVaultFromDb(vaultId: string): Promise<{
  pages: NotePage[];
  blocks: NoteBlock[];
  books: NoteBook[];
  concepts: Concept[];
  pageLinks: PageLink[];
} | null> {
  const vault = await getVaultById(vaultId);
  if (!vault) return null;

  const [pages, blocks, books, concepts, pageLinks] = await Promise.all([
    getPagesByVault(vaultId),
    getBlocksByVault(vaultId),
    getBooksByVault(vaultId),
    getConceptsByVault(vaultId),
    getPageLinksByVault(vaultId),
  ]);

  return { pages, blocks, books, concepts, pageLinks };
}

// ═══════════════════════════════════════════════════════════════════
// Check if notes exist in DB (for migration detection)
// ═══════════════════════════════════════════════════════════════════

export async function hasNotesInDb(): Promise<boolean> {
  const rows = await db.select({ id: noteVault.id }).from(noteVault).limit(1);
  return rows.length > 0;
}
