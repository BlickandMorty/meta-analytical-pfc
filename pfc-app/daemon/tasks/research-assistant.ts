// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Research Assistant â€” finds and answers research questions in notes
//
// Runs every 2-4h. Scans for todo blocks and blocks containing "?"
// that look like research questions. Uses LLM to identify genuine
// questions and generates draft answer blocks.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { generateText } from 'ai';
import { stripHtml, generateBlockId } from '@/lib/notes/types';
import type { DaemonTask } from '../scheduler';
import type { DaemonContext } from '../context';

export const researchAssistant: DaemonTask = {
  name: 'research-assistant',
  description: 'Find and answer research questions in notes',

  async run(ctx: DaemonContext): Promise<string> {
    const vaultId = ctx.notes.getActiveVaultId();
    if (!vaultId) return 'No active vault';

    const pages = ctx.notes.getPages(vaultId);
    const blocks = ctx.notes.getBlocks(vaultId);

    // Find potential research questions:
    // 1. Todo blocks (unchecked)
    // 2. Blocks containing "?" that might be questions
    const candidates: Array<{
      block: typeof blocks[0];
      page: typeof pages[0];
      text: string;
    }> = [];

    for (const block of blocks) {
      const text = stripHtml(block.content).trim();
      if (!text) continue;

      // Skip blocks already answered by the daemon
      if (block.properties.autoGenerated === 'true') continue;
      if (block.properties.daemonAnswered === 'true') continue;

      const isQuestion = text.includes('?') && text.length > 15;
      const isTodo = block.type === 'todo' && !block.properties.checked;

      if (isQuestion || isTodo) {
        const page = pages.find(p => p.id === block.pageId);
        if (page) {
          candidates.push({ block, page, text });
        }
      }
    }

    if (candidates.length === 0) return 'No research questions found';

    // Limit to first 5 candidates per run
    const batch = candidates.slice(0, 5);
    const model = ctx.resolveModel();

    ctx.log.task('research-assistant', `Evaluating ${batch.length} potential research questions`);

    // Ask LLM to identify which are genuine research questions
    const questionTexts = batch.map((c, i) => `${i + 1}. [${c.page.title}] ${c.text}`).join('\n');

    const filterResult = await generateText({
      model,
      system: `You identify genuine research questions from a list of text snippets from personal notes. A genuine research question is one that:
- Asks about facts, concepts, or relationships that could be researched
- Is NOT a personal reminder, todo, or rhetorical question

Respond with a JSON array of the numbers (1-indexed) that are genuine research questions.
Example: [1, 3, 5]`,
      prompt: questionTexts,
      maxOutputTokens: 128,
      temperature: 0.2,
    });

    let questionIndices: number[] = [];
    try {
      const match = filterResult.text.match(/\[[\s\S]*?\]/);
      if (match) questionIndices = JSON.parse(match[0]);
    } catch {
      return 'Failed to parse question filter response';
    }

    const questions = questionIndices
      .map(i => batch[i - 1])
      .filter((q): q is NonNullable<typeof q> => q !== undefined);

    if (questions.length === 0) return 'No genuine research questions identified';

    let answered = 0;

    for (const q of questions) {
      try {
        const result = await generateText({
          model,
          system: `You are a research assistant. Given a question from someone's personal notes, provide a concise, factual answer (2-4 paragraphs). Include specific details, dates, or numbers where relevant. If you're uncertain, say so.

Format your answer as plain text, not JSON. Do not include the question in your response.`,
          prompt: `Question from page "${q.page.title}":\n${q.text}`,
          maxOutputTokens: 1024,
          temperature: 0.5,
        });

        if (result.text.trim()) {
          // Create an answer block after the question block
          const now = Date.now();
          const answerBlock = {
            id: generateBlockId(),
            pageId: q.block.pageId,
            type: 'callout' as const,
            content: `<strong>ğŸ¤– Research Answer (auto-generated)</strong><br>${result.text.trim().replace(/\n/g, '<br>')}`,
            parentId: null,
            order: q.block.order + '5', // Insert after the question
            collapsed: false,
            indent: q.block.indent,
            properties: {
              autoGenerated: 'true',
              source: 'daemon-research-assistant',
              status: 'draft',
              answeredAt: new Date().toISOString(),
            },
            refs: [],
            createdAt: now,
            updatedAt: now,
          };

          ctx.notes.upsertBlock(answerBlock);
          answered++;
          ctx.log.task('research-assistant', `Answered question in "${q.page.title}": ${q.text.slice(0, 60)}...`);
        }
      } catch (err) {
        ctx.log.error(`Failed to research: ${q.text.slice(0, 60)}...: ${err instanceof Error ? err.message : String(err)}`);
      }
    }

    return `Answered ${answered}/${questions.length} research questions`;
  },
};
