import Database from 'better-sqlite3';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import * as schema from './schema';
import path from 'path';

const DB_PATH = path.join(process.cwd(), 'pfc.db');

let _sqlite: ReturnType<typeof Database> | null = null;
let _db: ReturnType<typeof drizzle<typeof schema>> | null = null;
let _initialized = false;

function getSqlite() {
  if (!_sqlite) {
    _sqlite = new Database(DB_PATH);
    _sqlite.pragma('journal_mode = WAL');
    _sqlite.pragma('busy_timeout = 5000');
    _sqlite.pragma('synchronous = NORMAL');
    _sqlite.pragma('foreign_keys = true');
    _sqlite.pragma('temp_store = memory');
  }
  return _sqlite;
}

function initDb() {
  if (_initialized) return;
  const sqlite = getSqlite();

  // Create drizzle instance and cache it for reuse by getDb()
  _db = drizzle(sqlite, { schema });

  // Run Drizzle migrations — schema.ts is the single source of truth.
  // Migration files in lib/db/migrations/ are generated by `npx drizzle-kit generate`.
  migrate(_db, {
    migrationsFolder: path.join(process.cwd(), 'lib', 'db', 'migrations'),
  });

  _initialized = true;
}

// Lazy getter — only creates the connection when accessed
function getDb() {
  initDb();
  // _db is always set by initDb()
  return _db!;
}

// For backward compatibility, export as `db` using a Proxy
export const db = new Proxy({} as ReturnType<typeof drizzle<typeof schema>>, {
  get(_target, prop) {
    const realDb = getDb();
    // SAFETY: Proxy get trap requires dynamic property access on the drizzle instance.
    // The prop is forwarded as-is; drizzle's own runtime handles unknown keys safely.
    const value = (realDb as unknown as Record<string | symbol, unknown>)[prop];
    if (typeof value === 'function') {
      return (value as (...args: unknown[]) => unknown).bind(realDb);
    }
    return value;
  },
});

// ═══════════════════════════════════════════════════════════════════
// Transaction helper — wraps synchronous work in a SQLite transaction
// Uses better-sqlite3's `.transaction()` which auto-commits on success
// and auto-rolls-back on exception.
// ═══════════════════════════════════════════════════════════════════

/**
 * Execute `fn` inside a SQLite transaction. If `fn` throws, the
 * transaction is rolled back. Returns whatever `fn` returns.
 *
 * NOTE: better-sqlite3 transactions are synchronous. The callback
 * must not contain real async I/O. Our drizzle `.run()` calls are
 * synchronous under better-sqlite3, so wrapping them is safe.
 */
export function withTransaction<T>(fn: () => T): T {
  const sqlite = getSqlite();
  initDb(); // ensure tables exist
  const txn = sqlite.transaction(fn);
  return txn();
}

