// ═══════════════════════════════════════════════════════════════════
// Daily Brief — generates a journal page summarizing recent activity
//
// Runs once per day at configured hour. Creates a journal page
// with a summary of notes updated in the last 24h, key insights,
// and suggested focus areas.
// ═══════════════════════════════════════════════════════════════════

import { generateText } from 'ai';
import { buildDailyBriefPrompt } from '@/lib/notes/learning-prompts';
import { stripHtml, generatePageId, generateBlockId } from '@/lib/notes/types';
import type { DaemonTask } from '../scheduler';
import type { DaemonContext } from '../context';

export const dailyBrief: DaemonTask = {
  name: 'daily-brief',
  description: 'Generate a daily knowledge brief',

  async run(ctx: DaemonContext): Promise<string> {
    const vaultId = ctx.notes.getActiveVaultId();
    if (!vaultId) return 'No active vault';

    const pages = ctx.notes.getPages(vaultId);
    const blocks = ctx.notes.getBlocks(vaultId);

    if (pages.length === 0) return 'No pages in vault';

    // Find pages updated in last 24h
    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
    const recentPages = pages.filter(p => p.updatedAt > oneDayAgo);

    // Build content for recent activity
    const recentActivity = recentPages.map(page => {
      const pageBlocks = blocks
        .filter(b => b.pageId === page.id)
        .sort((a, b) => a.order.localeCompare(b.order));
      const content = pageBlocks.map(b => stripHtml(b.content)).filter(Boolean).join('\n');
      return `## ${page.title}\n${content.slice(0, 500)}`;
    }).join('\n\n');

    // Build full notes summary (truncated)
    const allContent = pages.map(page => {
      const pageBlocks = blocks
        .filter(b => b.pageId === page.id)
        .sort((a, b) => a.order.localeCompare(b.order));
      return `## ${page.title}\n${pageBlocks.map(b => stripHtml(b.content)).filter(Boolean).join('\n')}`;
    }).join('\n\n---\n\n').slice(0, 24_000);

    const today = new Date();
    const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

    const model = ctx.resolveModel();
    const prompt = buildDailyBriefPrompt(allContent, recentActivity || '(No recent changes)', todayStr);

    ctx.log.task('daily-brief', `Generating brief for ${todayStr} (${recentPages.length} recently updated pages)`);

    const result = await generateText({
      model,
      system: prompt.system,
      prompt: prompt.user,
      maxOutputTokens: 2048,
      temperature: 0.6,
    });

    // Parse the response
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return 'LLM response did not contain valid JSON';

    let parsed: {
      title?: string;
      sections?: Array<{ heading: string; blocks: string[] }>;
    };

    try {
      parsed = JSON.parse(jsonMatch[0]);
    } catch {
      return 'Failed to parse daily brief response';
    }

    const title = parsed.title || `Daily Brief — ${todayStr}`;
    const sections = parsed.sections ?? [];

    // Create a journal page for today's brief
    const now = Date.now();
    const pageId = generatePageId();

    ctx.notes.upsertPage({
      id: pageId,
      title,
      name: title.toLowerCase(),
      isJournal: true,
      journalDate: todayStr,
      properties: { autoGenerated: 'true', source: 'daemon-daily-brief' },
      tags: ['daily-brief', 'auto-generated'],
      favorite: false,
      pinned: false,
      createdAt: now,
      updatedAt: now,
    }, vaultId);

    // Create blocks for each section
    let blockIndex = 0;
    for (const section of sections) {
      // Heading block
      const headingBlock = {
        id: generateBlockId(),
        pageId,
        type: 'heading' as const,
        content: section.heading,
        parentId: null,
        order: `a${blockIndex++}`,
        collapsed: false,
        indent: 0,
        properties: { level: '2', autoGenerated: 'true' },
        refs: [],
        createdAt: now,
        updatedAt: now,
      };
      ctx.notes.upsertBlock(headingBlock);

      // Content blocks
      for (const text of section.blocks) {
        const contentBlock = {
          id: generateBlockId(),
          pageId,
          type: 'paragraph' as const,
          content: text,
          parentId: null,
          order: `a${blockIndex++}`,
          collapsed: false,
          indent: 0,
          properties: { autoGenerated: 'true' },
          refs: [],
          createdAt: now,
          updatedAt: now,
        };
        ctx.notes.upsertBlock(contentBlock);
      }
    }

    return `Created "${title}" with ${sections.length} sections`;
  },
};
